# -*- coding: utf-8 -*-
"""
Created on Fri May 13 10:00:09 2022

@author: agerlt
"""

from numpy import histogramdd
from scipy.spatial.transform import Rotation as R
from scipy.ndimage import gaussian_filter

class ODF:
    """
    Words go here
    """

# ============================ #
#          Initialize          #
# ============================ #
    def __init__(self, orientations, sigma=1, bin_count=100, method="fast"):
        '''
        Generates ODF over rotations, given orientations. Only "Fast" method is
        supported, currently.

        The ODF is generated by first creating a histogram with forced bin numbers.
        Second, the histogram is convolved with a Gaussian kernel with fixed variance,
        sigma.

        Inputs:
        --------------
        orientations : np.array
            This is an array of orientations, in quaternion space.

        rotations : np.array
            This is an array of the rotations with some pre-defined resolution,
            also in quaternion space.

        bin_number : int
            Number of bins in one dimension (for a total of three, X, Y, and Z)
            we'd like to create the histogram over. (MUST BE NON-NEGATIVE)

        sigma : float
            Variance of the Gaussian kernel when we blur the histogram. (MUST BE
            GREATER THAN OR EQUAL TO ZERO))

        ***method*** : str
            "fast" ONLY for now, eventually "accurate". WARNING:
            Currently only "fast" (AND INACCURATE) ODF generation is supported.


        Outputs:
        --------------
        odf : np.array
            This array should contain the values of the smoothed histogram
            that we want.

        Dependencies:
        --------------
        from numpy import histogramdd
        from scipy.spatial.transform import Rotation as R
        from scipy.ndimage import gaussian_filter


        '''
        ori_xyz = R.from_quat(orientations.data).as_mrp()

        hist = histogramdd(
            ori_xyz,bin_count,
            range = [[-1, 1], [-1, 1], [-1, 1]],
            )[0]

        self.block = gaussian_filter(hist, sigma=sigma)
        self.bins = bin_count


# ============================ #
#          Methods             #
# ============================ #

    def query(self, input_oris):
        mrp_querys = R.from_quat(input_oris.data).as_mrp()
        indices = ((((input_oris+1)/2)*self.bins).astype('uint'))
        likelyhood = [self.block[ind[0],ind[1],ind[2]] for ind in indices]
        return(likelyhood)
